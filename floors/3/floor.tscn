[gd_scene load_steps=2 format=3 uid="uid://cjoqg6ifqsoq4"]

[sub_resource type="GDScript" id="GDScript_y80um"]
script/source = "extends Node3D

# put scenes you want added to your floor here
# shelf is 4x2.5x.5
var shelf_scene = preload(\"res://blender_assets/bookshelf_3m.blend\")
var table_scene = preload(\"res://blender_assets/table.blend\")
var dirt_floor = preload(\"res://blender_assets/dirt_floor.blend\")
var cobble_floor = preload(\"res://blender_assets/cobble_floor.blend\")

# hardcoding the size of the floors to 50x50 meters,
#	25 meters left of the origin, 25 right of the origin
var rowNum = -25
var colNum = -25

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	print(\"Loading flooring.\\n\")
	# make a text file of 50 columns and 50 rows representing the
	#	floor layout. See floor.txt for example
	var layoutFile = FileAccess.open(\"res://floors/3/floor.txt\", FileAccess.READ)
	var rando = RandomNumberGenerator.new()
	var row = null
	var floor = null
	var item = null
	var item_placement_y = 0
	var item_placement_rot = 0
	var floor_rot = [0, 90, 180, 270]
	
	while layoutFile.get_position() < layoutFile.get_length():
		row = layoutFile.get_line()
		for tile in row:
			# like a switch statement in C++
			match tile:
				\".\":
					floor = cobble_floor.instantiate()
				\"d\":
					floor = dirt_floor.instantiate()
				# add whatever else you want automatically added to the floor
				#	here
			if (floor):
				add_child(floor)
				# the top of flooring should always be at y level zero
				#	so lower our 1m cube half a meter
				floor.set_global_position(Vector3(colNum,-0.5,rowNum))
				# randomly orient the floor to get some variety
				floor.set_rotation_degrees(Vector3(0,floor_rot[rando.randi_range(0,3)],0))
				floor = null
			colNum += 1
		colNum = -25
		rowNum += 1
	rowNum = -25
	print(\"Loading floor items.\\n\")
	layoutFile = FileAccess.open(\"res://floors/3/layout.txt\", FileAccess.READ)
	while layoutFile.get_position() < layoutFile.get_length():
		row = layoutFile.get_line()
		for tile in row:
			match tile:
				\"h\":
					item = shelf_scene.instantiate()
					# set this so that your item \"sits\" on the ground,
					#	which is at y == 0. Or figure out how to snap
					#	to the ground using this code.
					item_placement_y = 1.25
					item_placement_rot = 0
				\"v\":
					item = shelf_scene.instantiate()
					item_placement_y = 1.25
					item_placement_rot = 90
				\"t\":
					item = table_scene.instantiate()
					item_placement_y = 0.5
			if (item):
				add_child(item)
				# prolly should just divide height of item and assign
				#	result to Vector3.y...
				item.set_global_position(Vector3(colNum,item_placement_y,rowNum))
				item.set_rotation_degrees(Vector3(0,item_placement_rot,0))
				item = null
			colNum += 1
		colNum = -25
		rowNum += 1
	rowNum = -25
	#print(\"Loading lighting.\")
	#for x in range(rowNum, -rowNum):
	#	for y in range(colNum, -colNum):
	#		

# Called every frame. 'delta' is the elapsed time since the previous frame.
# I just put this here so I have a camera to see my work.
func _process(delta: float) -> void:
	var camera = find_child(\"Camera3D\")
	var rot = camera.get_rotation_degrees()
	camera.set_rotation_degrees(Vector3(-90,90,0))
	camera.set_global_position(Vector3(0,40,0))
"

[node name="3" type="Node3D"]
script = SubResource("GDScript_y80um")

[node name="Camera3D" type="Camera3D" parent="."]

[node name="OmniLight3D" type="OmniLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 3, 0)
light_color = Color(1, 1, 0.878431, 1)
omni_range = 30.0
omni_attenuation = 0.0
